StructuredBuffer<float> weights; // gate + up + down (joined in this order, they were flattened from (output_features, input_features) => as the weights of dense module)
RWStructuredBuffer<float> input; //this is also used to write the output values in it.
RWStructuredBuffer<float> intermediate;

int activation_type; // 0 for silu, 1 for gelu
int hidden_size; 
int intermediate_size; 
int batch_size; 
int seq_len; 

float silu(float x)
{
    return x / (1.0f + exp(-x));
    
}
float safe_tanh(float x) // in llm sit seems like a lot of big numbers are running, it seems they are stabilized only by layernorms
{
    float a = abs(x);
    float e = exp(-2.0f * a);
    return sign(x) * ((1.0f - e) / (1.0f + e));
    
    // return sign(x) * (1.0f - 2.0f / (1.0f + exp(-2.0f * abs(x))));
}

float gelu(float x)
{
    return 0.5f * x * (1.0f + tanh(0.79788456080286535587989211986876f * (x + 0.044715f * x * x * x)));

}


#pragma kernel GateUp
[numthreads(64, 8, 1)]
void GateUp(uint3 id : SV_DispatchThreadID)
{
    const uint i_idx = id.x; 
    const uint l_idx = id.y; 
    const uint b_idx = id.z;

    if (i_idx >= intermediate_size || l_idx >= seq_len || b_idx >= batch_size)
        return;

    const uint H = hidden_size;
    const uint I = intermediate_size;

    const uint gate_off = 0u;
    const uint up_off = H * I;

    const uint input_base = ((b_idx * seq_len) + l_idx) * H;

    float g = 0.0;
    float u = 0.0;

    for (uint k = 0; k < H; ++k)
    {
        const float x = input[input_base + k];
        g += x * weights[gate_off + i_idx * H + k];
        u += x * weights[up_off + i_idx * H + k];
    }

    const uint inter_idx = ((b_idx * seq_len) + l_idx) * I + i_idx;
    if(activation_type == 0)
        intermediate[inter_idx] = silu(g) * u;
    else if(activation_type == 1)
        intermediate[inter_idx] = gelu(g) * u;
    else
        intermediate[inter_idx] = 0.0;
    
}

#pragma kernel Down
[numthreads(64, 8, 1)]
void Down(uint3 id : SV_DispatchThreadID)
{
    const uint h_idx = id.x; 
    const uint l_idx = id.y; 
    const uint b_idx = id.z; 

    if (h_idx >= hidden_size || l_idx >= seq_len || b_idx >= batch_size)
        return;

    const uint down_off = 2u * hidden_size * intermediate_size;

    const uint inter_base = ((b_idx * seq_len) + l_idx) * intermediate_size;

    float acc = 0.0;

    for (uint i = 0; i < intermediate_size; ++i)
    {
        const float z = intermediate[inter_base + i];
        acc += z * weights[down_off + h_idx * intermediate_size + i];
    }

    const uint out_idx = ((b_idx * seq_len) + l_idx) * hidden_size + h_idx;
    input[out_idx] = acc;
}








#pragma kernel GateUp1Vec
[numthreads(256, 1, 1)]
void GateUp1Vec(uint3 id : SV_DispatchThreadID)
{
    const uint i_idx = id.x;
    const uint l_idx = id.y;
    const uint b_idx = id.z;

    if (i_idx >= intermediate_size || l_idx >= seq_len || b_idx >= batch_size)
        return;

    const uint H = hidden_size;
    const uint I = intermediate_size;

    const uint gate_off = 0u;
    const uint up_off = H * I;

    const uint input_base = ((b_idx * seq_len) + l_idx) * H;

    float g = 0.0;
    float u = 0.0;

    for (uint k = 0; k < H; ++k)
    {
        const float x = input[input_base + k];
        g += x * weights[gate_off + i_idx * H + k];
        u += x * weights[up_off + i_idx * H + k];
    }

    const uint inter_idx = ((b_idx * seq_len) + l_idx) * I + i_idx;
    if (activation_type == 0)
        intermediate[inter_idx] = silu(g) * u;
    else if (activation_type == 1)
        intermediate[inter_idx] = gelu(g) * u;
    else
        intermediate[inter_idx] = 0.0;
    
}

#pragma kernel Down1Vec
[numthreads(256, 1, 1)]
void Down1Vec(uint3 id : SV_DispatchThreadID)
{
    const uint h_idx = id.x;
    const uint l_idx = id.y;
    const uint b_idx = id.z;

    if (h_idx >= hidden_size || l_idx >= seq_len || b_idx >= batch_size)
        return;

    const uint down_off = 2u * hidden_size * intermediate_size;

    const uint inter_base = ((b_idx * seq_len) + l_idx) * intermediate_size;

    float acc = 0.0;

    for (uint i = 0; i < intermediate_size; ++i)
    {
        const float z = intermediate[inter_base + i];
        acc += z * weights[down_off + h_idx * intermediate_size + i];
    }

    const uint out_idx = ((b_idx * seq_len) + l_idx) * hidden_size + h_idx;
    input[out_idx] = acc;
}